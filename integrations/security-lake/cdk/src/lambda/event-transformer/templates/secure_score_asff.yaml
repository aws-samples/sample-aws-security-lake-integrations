name: "secure_score_to_asff"
input_schema: "azure_secure_score"
output_schema: "asff_compliance_finding"

# JSONPath extractors for Azure Secure Score data
extractors:
  # Core Score Fields
  score_id: "$.event_data.id"
  score_name: "$.event_data.properties.displayName"
  score_description: "$.event_data.properties.description"
  score_current: "$.event_data.properties.score.current"
  score_max: "$.event_data.properties.score.max"
  score_percentage: "$.event_data.properties.score.percentage"
  
  # Metadata
  subscription_id: "$.event_data.properties.subscriptionId"
  time_generated: "$.event_data.properties.timestamp"
  
  # Control Information
  control_name: "$.event_data.properties.control.name"
  control_description: "$.event_data.properties.control.description"
  control_id: "$.event_data.properties.control.id"
  
  # Status Information
  status: "$.event_data.properties.status"
  percentage_score: "$.event_data.properties.percentageScore"
  
  # Resource Information
  resource_id: "$.event_data.id"
  resource_type: "$.event_data.type"

# ASFF template for compliance findings
template: |
  {
    "SchemaVersion": "2018-10-08",
    "Id": "{{ extractors.score_id | default(generate_uuid()) }}",
    "ProductArn": "arn:aws:securityhub:{{ aws_region }}:{{ aws_account_id }}:product/{{ aws_account_id }}/default",
    "ProductName": "{{ config.asff_product_name | default('Microsoft Secure Score') }}",
    "CompanyName": "Microsoft",
    "GeneratorId": "azure-secure-score",
    "AwsAccountId": "{{ aws_account_id }}",
    "Types": ["Software and Configuration Checks/Industry and Regulatory Standards"],
    "FirstObservedAt": "{{ extractors.time_generated | normalize_timestamp }}",
    "CreatedAt": "{{ extractors.time_generated | normalize_timestamp }}",
    "UpdatedAt": "{{ extractors.time_generated | normalize_timestamp }}",
    "Severity": {
      "Label": "{{ extractors.score_current | score_to_severity(extractors.score_max) }}",
      "Normalized": {{ extractors.score_current | score_to_severity_normalized(extractors.score_max) }}
    },
    "FindingProviderFields": {
      "Types": ["Software and Configuration Checks/Industry and Regulatory Standards"],
      "Severity": {
        "Label": "{{ extractors.score_current | score_to_severity(extractors.score_max) }}",
        "Original": "{{ extractors.score_current | score_to_severity(extractors.score_max) | upper }}"
      }
    },
    "Title": "{{ extractors.score_name | default('Azure Secure Score') }}",
    "Description": "{{ extractors.score_description | default('Security posture assessment for Azure resources') | replace('\n', ' ') | replace('\"', '\\\"') | truncate(1024) }}",
    "Remediation": {
      "Recommendation": {
        "Text": "Review and implement security recommendations to improve your secure score",
        "Url": "https://portal.azure.com/#blade/Microsoft_Azure_Security/SecurityMenuBlade/22"
      }
    },
    "ProductFields": {
      "azure/subscriptionId": "{{ extractors.subscription_id | default('Unknown') }}",
      "azure/currentScore": "{{ extractors.score_current | default(0) }}",
      "azure/maxScore": "{{ extractors.score_max | default(0) }}",
      "azure/scorePercentage": "{{ extractors.score_percentage | default(0) }}",
      "aws/securityhub/ProductName": "{{ config.asff_product_name | default('Microsoft Secure Score') }}",
      "aws/securityhub/CompanyName": "Microsoft",
      "aws/securityhub/FindingId": "arn:aws:securityhub:{{ aws_region }}:{{ aws_account_id }}:product/{{ aws_account_id }}/default/{{ extractors.score_id | default(generate_uuid()) }}"
    },
    "Compliance": {
      "Status": "{{ extractors.score_current | score_to_compliance_status(extractors.score_max) }}",
      "RelatedRequirements": ["Azure Secure Score"],
      "StatusReasons": [
        {
          "ReasonCode": "{{ extractors.score_current | score_to_reason_code(extractors.score_max) }}",
          "Description": "Current score: {{ extractors.score_current | default(0) }} out of {{ extractors.score_max | default(0) }} ({{ extractors.score_percentage | default(0) }}%)"
        }
      ]
    },
    "Resources": [
      {
        "Type": "AwsAccount",
        "Id": "{{ aws_account_id }}",
        "Partition": "aws",
        "Region": "{{ aws_region }}"
      }
    ],
    "Workflow": {"Status": "NEW"},
    "Region": "{{ aws_region }}",
    "WorkflowState": "NEW",
    "RecordState": "ACTIVE"
  }

# Custom filters for Azure Secure Score ASFF transformation
filters:
  score_to_reason_code: |
    def score_to_reason_code(score_current, score_max=100):
        # Valid ASFF ReasonCode values: NOT_COMPLIANT, PASSED, NOT_APPLICABLE, DATA_NOT_AVAILABLE, etc.
        try:
            if score_current is None or score_max is None:
                return 'DATA_NOT_AVAILABLE'
            current = float(score_current) if score_current else 0
            maximum = float(score_max) if score_max else 100
            if maximum == 0:
                return 'DATA_NOT_AVAILABLE'
            percentage = (current / maximum) * 100
            if percentage >= 90:
                return 'PASSED'
            else:
                return 'NOT_COMPLIANT'
        except Exception:
            return 'DATA_NOT_AVAILABLE'
  
  score_to_compliance_status: |
    def score_to_compliance_status(score_current, score_max=100):
        try:
            if score_current is None or score_max is None:
                return 'NOT_AVAILABLE'
            current = float(score_current) if score_current else 0
            maximum = float(score_max) if score_max else 100
            if maximum == 0:
                return 'NOT_AVAILABLE'
            percentage = (current / maximum) * 100
            if percentage >= 90:
                return 'PASSED'
            elif percentage >= 70:
                return 'WARNING'
            else:
                return 'FAILED'
        except Exception:
            return 'NOT_AVAILABLE'
  
  score_to_severity: |
    def score_to_severity(score_current, score_max=100):
        try:
            if score_current is None or score_max is None:
                return 'INFORMATIONAL'
            current = float(score_current) if score_current else 0
            maximum = float(score_max) if score_max else 100
            if maximum == 0:
                return 'INFORMATIONAL'
            percentage = (current / maximum) * 100
            if percentage >= 90:
                return 'INFORMATIONAL'
            elif percentage >= 70:
                return 'LOW'
            elif percentage >= 50:
                return 'MEDIUM'
            else:
                return 'HIGH'
        except Exception:
            return 'INFORMATIONAL'
  
  score_to_severity_normalized: |
    def score_to_severity_normalized(score_current, score_max=100):
        try:
            if score_current is None or score_max is None:
                return 0
            current = float(score_current) if score_current else 0
            maximum = float(score_max) if score_max else 100
            if maximum == 0:
                return 0
            percentage = (current / maximum) * 100
            if percentage >= 90:
                return 0
            elif percentage >= 70:
                return 10
            elif percentage >= 50:
                return 40
            else:
                return 70
        except Exception:
            return 0
  
  normalize_timestamp: |
    def normalize_timestamp(timestamp_str):
        from datetime import datetime
        if not timestamp_str:
            return datetime.utcnow().strftime('%Y-%m-%dT%H:%M:%S.%fZ')
        try:
            if timestamp_str.endswith('Z'):
                return timestamp_str
            elif '+' in timestamp_str or '-' in timestamp_str[-6:]:
                dt = datetime.fromisoformat(timestamp_str.replace('Z', '+00:00'))
                return dt.strftime('%Y-%m-%dT%H:%M:%S.%fZ')
            else:
                return timestamp_str + 'Z'
        except Exception:
            return datetime.utcnow().strftime('%Y-%m-%dT%H:%M:%S.%fZ')
  
  truncate: |
    def truncate(text, max_length=1024):
        if not text or not isinstance(text, str):
            return ''
        if len(text) <= max_length:
            return text
        return text[:max_length-3] + '...'
  
  replace: |
    def replace(text, old, new):
        if not text:
            return ''
        return str(text).replace(old, new)
  
  generate_uuid: |
    def generate_uuid():
        import uuid
        return str(uuid.uuid4())