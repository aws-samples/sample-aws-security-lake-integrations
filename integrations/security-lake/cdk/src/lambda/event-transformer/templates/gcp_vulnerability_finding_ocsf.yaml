name: "gcp_scc_vulnerability_to_ocsf_vulnerability_finding"
input_schema: "gcp_scc_finding"
output_schema: "ocsf_vulnerability_finding_v110"

# JSONPath expressions to extract data from GCP Security Command Center findings
extractors:
  # Core Finding Fields
  finding_name: "$.event_data.resource.displayName"
  finding_id: "$.event_data.finding.name"
  parent: "$.event_data.finding.parent"
  resource_name: "$.event_data.finding.resourceName"
  state: "$.event_data.finding.state"
  category: "$.event_data.finding.category"
  external_uri: "$.event_data.finding.externalUri"
  source_properties: "$.event_data.finding.sourceProperties"
  
  # Security Marks
  security_marks: "$.event_data.finding.securityMarks"
  
  # Timestamps
  event_time: "$.event_data.finding.eventTime"
  create_time: "$.event_data.finding.createTime"
  
  # Severity
  severity: "$.event_data.finding.severity"
  
  # Vulnerability Specific
  vulnerability_name: "$.event_data.finding.vulnerability.cve.id"
  cve_id: "$.event_data.finding.vulnerability.cve.id"
  cvss_score: "$.event_data.finding.vulnerability.cve.cvssv3.baseScore"
  cvss_vector: "$.event_data.finding.vulnerability.cve.cvssv3.attackVector"
  cvss_severity: "$.event_data.finding.vulnerability.cve.cvssv3.baseSeverity"
  references: "$.event_data.finding.vulnerability.cve.references"
  upstream_fix_available: "$.event_data.finding.vulnerability.cve.upstreamFixAvailable"
  
  # GCP Resource Information
  project_id: "$.event_data.finding.resourceName"
  project_display_name: "$.event_data.resource.projectDisplayName"
  resource_type: "$.event_data.resource.type"
  resource_parent: "$.event_data.gcpMetadata.parent"
  resource_display_name: "$.event_data.resource.displayName"
  folders: "$.event_data.gcpMetadata.folders"
  
  # Finding Class Information
  finding_class: "$.event_data.finding.findingClass"
  indicator_of_compromise: "$.event_data.finding.indicator.domains"
  
  # MITRE ATT&CK
  mitre_attack: "$.event_data.finding.mitreAttack"
  
  # Processing Metadata
  processing_source: "$.processing_metadata.source"
  processor_version: "$.processing_metadata.processor_version"
  processed_timestamp: "$.processing_metadata.processed_timestamp"
  notificationConfigName: "$.event_data.notificationConfigName"

# OCSF v1.1.0 compliant template for Vulnerability Finding
template: |
  {
    "version": "1.1.0",
    "activity_id": 1,
    "activity_name": "Create",
    "category_uid": 2,
    "category_name": "Findings",
    "class_uid": 2002,
    "class_name": "Vulnerability Finding",
    "type_uid": 200201,
    "type_name": "Vulnerability Finding: Create",
    "time": {{ extractors.event_time | to_unix_timestamp_ms | default(extractors.create_time | to_unix_timestamp_ms) }},
    "severity_id": {{ extractors.severity | map_gcp_severity_to_ocsf }},
    "severity": "{{ extractors.severity | format_severity }}",
    "status": "{{ extractors.state | map_gcp_state_to_status }}",
    "status_id": {{ extractors.state | map_gcp_state_to_status_id }},
    "cloud": {
      "provider": "GCP",
      "account": {
        "uid": "{{ extractors.project_id | extract_gcp_project_id }}",
        "name": "{{ extractors.project_display_name | default('') }}",
        "type": "GCP Project",
        "type_id": 10
      }
      {% set org_id = extractors.parent | extract_gcp_org_id %}{% if org_id %},
      "org": {
        "uid": "{{ org_id }}",
        "name": "{{ extractors.parent | extract_gcp_org_name }}"
      }{% endif %}
      {% set region = extractors.resource_name | extract_gcp_region %}{% if region %},
      "region": "{{ region }}"{% endif %}
    },
    "finding_info": {
      "uid": "{{ extractors.finding_id | extract_finding_uid }}",
      "title": "{{ extractors.category | default('GCP Security Command Center Finding') }}",
      "desc": "{{ extractors.category | default('') }} - {{ extractors.cve_id | default('Vulnerability detected') }}"
      {% if extractors.external_uri %},
      "src_url": "{{ extractors.external_uri }}"{% endif %},
      "types": ["{{ extractors.category }}"]
      {% if extractors.finding_class %},
      "related_events": [
        {
          "type": "{{ extractors.finding_class }}",
          "type_uid": {{ extractors.finding_class | map_finding_class }}
        }
      ]{% endif %},
      "created_time": {{ extractors.create_time | to_unix_timestamp_ms }},
      "modified_time": {{ extractors.event_time | to_unix_timestamp_ms }},
      "product": {
        "name": "Security Command Center",
        "vendor_name": "Google Cloud",
        "version": "1.0"
      }
    },
    "vulnerabilities":
      {
        {% if extractors.cve_id %}
        "cve": {
          "uid": "{{ extractors.cve_id }}",
          "type": "CVE",
          "created_time": {{ extractors.create_time | to_unix_timestamp_ms }}
          {% if extractors.cvss_score %},
          "cvss": [
            {
              "base_score": {{ extractors.cvss_score }},
              "severity": "{{ extractors.cvss_severity | default('') }}",
              "version": "3.x",
              "vector_string": "{{ extractors.cvss_vector | default('') }}"
            }
          ]{% endif %}
          {% if extractors.references %},
          "references": [
            {% for ref in extractors.references %}
            "{{ ref }}"{{ ',' if not loop.last else '' }}
            {% endfor %}
          ]{% endif %}
        },
        {% endif %}
        "title": "{{ extractors.vulnerability_name | default(extractors.cve_id) | default('Vulnerability') }}",
        "desc": "{{ extractors.category }}{% if extractors.upstream_fix_available %} - Fix Available{% endif %}"
        {% if extractors.cvss_score %},
        "severity": "{{ extractors.cvss_severity | default('') }}"{% endif %}
        {% if extractors.upstream_fix_available %},
        "fix_available": {{ extractors.upstream_fix_available | lower }}{% endif %}
      }
    {% if extractors.mitre_attack %},
    "attacks": [
      {% for attack in extractors.mitre_attack.techniques %}
      {
        "version": "{{ extractors.mitre_attack.version | default('v13') }}",
        "tactics": [
          {% for tactic in attack.tactics %}
          {
            "name": "{{ tactic }}",
            "uid": "{{ tactic | map_mitre_tactic_uid }}"
          }{{ ',' if not loop.last else '' }}
          {% endfor %}
        ],
        "technique": {
          "name": "{{ attack.name }}",
          "uid": "{{ attack.id }}"
        }
      }{{ ',' if not loop.last else '' }}
      {% endfor %}
    ]{% endif %}
    {% if extractors.resource_name %},
    "resources": {
      "uid": "{{ extractors.resource_name }}",
      "name": "{{ extractors.resource_display_name | default(extractors.resource_name | extract_resource_name) }}",
      "type": "{{ extractors.resource_type | default('') }}",
      "cloud_partition": "gcp-public",
      "region": "{{ extractors.resource_name | extract_gcp_region }}"{% if extractors.project_id %},
      "owner": {
        "account": {
          "uid": "{{ extractors.project_id | extract_gcp_project_id }}",
          "name": "{{ extractors.project_display_name | default('') }}"
        }
      }{% endif %},
      "role_id": 3,
      "role": "Affected"{% if extractors.folders %},
      "labels": [
        {% for folder in extractors.folders %}
        "folder:{{ folder.resourceFolder }}"{{ ',' if not loop.last else '' }}
        {% endfor %}
      ]{% endif %}
    }{% endif %}
    {% if extractors.resource_name %},
    "resource": {
      "uid": "{{ extractors.resource_name }}",
      "name": "{{ extractors.resource_display_name | default(extractors.resource_name | extract_resource_name) }}",
      "type": "{{ extractors.resource_type | default('') }}",
      "cloud_partition": "gcp-public",
      "region": "{{ extractors.resource_name | extract_gcp_region }}"{% if extractors.project_id %},
      "owner": {
        "account": {
          "uid": "{{ extractors.project_id | extract_gcp_project_id }}",
          "name": "{{ extractors.project_display_name | default('') }}"
        }
      }{% endif %},
      "role_id": 3,
      "role": "Affected"{% if extractors.folders %},
      "labels": [
        {% for folder in extractors.folders %}
        "folder:{{ folder.resourceFolder }}"{{ ',' if not loop.last else '' }}
        {% endfor %}
      ]{% endif %}
    }{% endif %}
    {% if extractors.upstream_fix_available %},
    "remediation": {
      "desc": "{% if extractors.upstream_fix_available %}An upstream fix is available for this vulnerability.{% else %}No upstream fix currently available.{% endif %} Please review the external references for more information.",
      "references": [
        {% if extractors.external_uri %}
        "{{ extractors.external_uri }}"{% if extractors.references %},{% endif %}
        {% endif %}
        {% if extractors.references %}
          {% for ref in extractors.references %}
          "{{ ref }}"{{ ',' if not loop.last else '' }}
          {% endfor %}
        {% endif %}
      ]
    }{% endif %},
    "metadata": {
      "version": "1.1.0",
      "product": {
        "name": "Google Security Command Center",
        "vendor_name": "Google Cloud",
        "version": "1.0",
        "feature": {
          "name": "{{ extractors.category }}"
        }
      },
      "profiles": ["security_control", "cloud"],
      "event_code": "{{ extractors.category }}"
      {% if extractors.processed_timestamp %},
      "logged_time": {{ extractors.processed_timestamp | to_unix_timestamp_ms }}{% endif %},
      "original_time": {{ extractors.event_time | default(extractors.create_time) | to_unix_timestamp_ms }},
      "correlation_uid": "{{ extractors.finding_id | extract_finding_uid }}"
      {% if extractors.notificationConfigName %},
      "labels": [
        "notification_config:{{ extractors.notificationConfigName | extract_notification_config_name }}"
      ]{% endif %}
    },
    "unmapped": {
      "source_properties": {{ extractors.source_properties | to_json | default('{}') }},
      "security_marks": {{ extractors.security_marks | to_json | default('{}') }},
      "raw_data": {{ gcp_event | to_json }}
    }    
  }

# Custom filters for GCP-specific data transformations
filters:
  to_unix_timestamp_ms: |
    def to_unix_timestamp_ms(timestamp_str):
        if not timestamp_str:
            return int(datetime.utcnow().timestamp() * 1000)
        try:
            if timestamp_str.endswith('Z'):
                dt = datetime.fromisoformat(timestamp_str.replace('Z', '+00:00'))
            elif '+' in timestamp_str or '-' in timestamp_str[-6:]:
                dt = datetime.fromisoformat(timestamp_str)
            else:
                dt = datetime.fromisoformat(timestamp_str + '+00:00')
            return int(dt.timestamp() * 1000)
        except:
            return int(datetime.utcnow().timestamp() * 1000)
  
  extract_gcp_project_id: |
    def extract_gcp_project_id(resource_name):
        # Extract from: organizations/123/sources/456/findings/789 or projects/my-project/...
        if not resource_name:
            return ''
        if 'projects/' in resource_name:
            parts = resource_name.split('projects/')
            if len(parts) > 1:
                project_part = parts[1].split('/')[0]
                return project_part
        return ''
  
  extract_gcp_org_id: |
    def extract_gcp_org_id(parent_name):
        # Extract from: organizations/123456789
        if not parent_name or 'organizations/' not in parent_name:
            return ''
        parts = parent_name.split('organizations/')
        if len(parts) > 1:
            return parts[1].split('/')[0]
        return ''
  
  extract_gcp_org_name: |
    def extract_gcp_org_name(parent_name):
        # Extract organization name from parent path
        if not parent_name or 'organizations/' not in parent_name:
            return ''
        parts = parent_name.split('organizations/')
        if len(parts) > 1:
            org_id = parts[1].split('/')[0]
            return f"Organization {org_id}"
        return ''
  
  extract_gcp_region: |
    def extract_gcp_region(resource_name):
        # Extract region from resource name if present
        if not resource_name:
            return 'global'
        if '/locations/' in resource_name:
            parts = resource_name.split('/locations/')
            if len(parts) > 1:
                return parts[1].split('/')[0]
        return 'global'
  
  extract_finding_uid: |
    def extract_finding_uid(finding_name):
        # Extract the finding ID from the full resource name
        if not finding_name:
            return ''
        parts = finding_name.split('/')
        if len(parts) > 0:
            return parts[-1]
        return finding_name
  
  extract_notification_config_name: |
    def extract_notification_config_name(config_name):
        # Extract notification config name from full path
        if not config_name:
            return ''
        parts = config_name.split('/')
        if len(parts) > 0:
            return parts[-1]
        return config_name
  
  map_gcp_severity_to_ocsf: |
    def map_gcp_severity_to_ocsf(severity):
        # Map GCP severity to OCSF severity_id
        severity_map = {
            'CRITICAL': 5,  # Critical
            'HIGH': 4,      # High
            'MEDIUM': 3,    # Medium
            'LOW': 2,       # Low
            'UNSPECIFIED': 1  # Informational
        }
        return severity_map.get(str(severity).upper(), 1)
  
  format_severity: |
    def format_severity(severity):
        if not severity:
            return 'Unknown'
        return str(severity).capitalize()
  
  map_gcp_state_to_status: |
    def map_gcp_state_to_status(state):
        # Map GCP finding state to OCSF status
        state_map = {
            'ACTIVE': 'New',
            'INACTIVE': 'Suppressed'
        }
        return state_map.get(str(state).upper(), 'Other')
  
  map_gcp_state_to_status_id: |
    def map_gcp_state_to_status_id(state):
        # Map GCP finding state to OCSF status_id
        state_map = {
            'ACTIVE': 1,  # New
            'INACTIVE': 4  # Suppressed
        }
        return state_map.get(str(state).upper(), 99)
  
  map_finding_class: |
    def map_finding_class(finding_class):
        # Map GCP finding class to OCSF type_uid
        class_map = {
            'THREAT': 200401,  # Detection Finding
            'VULNERABILITY': 200201,  # Vulnerability Finding
            'MISCONFIGURATION': 200101,  # Compliance Finding
            'OBSERVATION': 200001,  # Security Finding
            'SCC_ERROR': 200001  # Security Finding
        }
        return class_map.get(str(finding_class).upper(), 200001)
  
  extract_resource_name: |
    def extract_resource_name(resource_path):
        if not resource_path:
            return ''
        parts = resource_path.split('/')
        if len(parts) > 0:
            return parts[-1]
        return resource_path
  
  map_mitre_tactic_uid: |
    def map_mitre_tactic_uid(tactic_name):
        # Map MITRE tactic names to UIDs (simplified mapping)
        tactic_map = {
            'Reconnaissance': 'TA0043',
            'Resource Development': 'TA0042',
            'Initial Access': 'TA0001',
            'Execution': 'TA0002',
            'Persistence': 'TA0003',
            'Privilege Escalation': 'TA0004',
            'Defense Evasion': 'TA0005',
            'Credential Access': 'TA0006',
            'Discovery': 'TA0007',
            'Lateral Movement': 'TA0008',
            'Collection': 'TA0009',
            'Command and Control': 'TA0011',
            'Exfiltration': 'TA0010',
            'Impact': 'TA0040'
        }
        return tactic_map.get(tactic_name, 'TA0000')